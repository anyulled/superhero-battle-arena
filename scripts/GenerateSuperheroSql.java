///usr/bin/env jbang "$0" "$@" ; exit $?
//DEPS com.fasterxml.jackson.core:jackson-databind:2.15.2
//DEPS org.slf4j:slf4j-simple:2.0.9

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Iterator;
import java.util.concurrent.atomic.AtomicInteger;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class GenerateSuperheroSql {
    private static final Logger logger = LoggerFactory.getLogger(GenerateSuperheroSql.class);

    enum DatabaseType {
        H2("src/main/resources/db/migration/h2/V4__seed_superheroes.sql", false),
        POSTGRESQL("src/main/resources/db/migration/postgresql/V4__seed_superheroes.sql", true);

        final String outputPath;
        final boolean supportsOnConflict;

        DatabaseType(String outputPath, boolean supportsOnConflict) {
            this.outputPath = outputPath;
            this.supportsOnConflict = supportsOnConflict;
        }
    }

    public static void main(String[] args) throws IOException {
        Path inputPath = Paths.get("src/main/resources/all-superheroes.json");
        logger.info("Reading JSON from: {}", inputPath.toAbsolutePath());

        ObjectMapper mapper = new ObjectMapper();
        JsonNode root = mapper.readTree(inputPath.toFile());

        if (!root.isArray()) {
            logger.error("Root JSON element is not an array!");
            return;
        }

        for (DatabaseType dbType : DatabaseType.values()) {
            File outputFile = new File(dbType.outputPath);
            // Ensure parent directory exists
            outputFile.getParentFile().mkdirs();

            try (PrintWriter writer = new PrintWriter(new FileWriter(outputFile))) {
                writer.println("-- Seed data for superheroes (Generated by JBang script)");
                writer.println("-- Dialect: " + dbType.name());

                Iterator<JsonNode> elements = root.elements();
                AtomicInteger count = new AtomicInteger();

                while (elements.hasNext()) {
                    JsonNode hero = elements.next();
                    writeHeroInserts(writer, hero, dbType);
                    count.incrementAndGet();
                }

                logger.info("Generated SQL for {} heroes for {}.", count.get(), dbType.name());
                logger.info("Output written to: {}", outputFile.getAbsolutePath());
            }
        }
    }

    private static void writeHeroInserts(PrintWriter writer, JsonNode hero, DatabaseType dbType) {
        int id = hero.get("id").asInt();
        String name = escapeSql(getText(hero, "name"));
        String slug = escapeSql(getText(hero, "slug"));

        JsonNode bio = hero.get("biography");
        String alignment = bio != null ? escapeSql(getText(bio, "alignment")) : "neutral";
        String publisher = bio != null ? escapeSql(getText(bio, "publisher")) : null;

        String onConflict = dbType.supportsOnConflict ? " ON CONFLICT (id) DO NOTHING" : "";
        writer.printf(
                "INSERT INTO superheroes (id, name, slug, alignment, publisher) VALUES (%d, '%s', '%s', '%s', %s)%s;%n",
                id, name, slug, alignment, quoteOrNull(publisher), onConflict);

        // Powerstats & Cost
        JsonNode stats = hero.get("powerstats");
        int intel = getInt(stats, "intelligence");
        int str = getInt(stats, "strength");
        int speed = getInt(stats, "speed");
        int dur = getInt(stats, "durability");
        int power = getInt(stats, "power");
        int combat = getInt(stats, "combat");

        // Calculate cost: Sum of stats / 10, clamped between 10 and 100
        int totalStats = intel + str + speed + dur + power + combat;
        int cost = Math.clamp(totalStats / 6, 10, 100);

        String onConflictId = dbType.supportsOnConflict ? " ON CONFLICT (superhero_id) DO NOTHING" : "";
        writer.printf(
                "INSERT INTO superhero_powerstats (superhero_id, intelligence, strength, speed, durability, power, combat, cost) VALUES (%d, %d, %d, %d, %d, %d, %d, %d)%s;%n",
                id, intel, str, speed, dur, power, combat, cost, onConflictId);

        // Appearance
        JsonNode app = hero.get("appearance");
        if (app != null) {
            String gender = escapeSql(getText(app, "gender"));
            String race = escapeSql(getText(app, "race"));
            String eyeColor = escapeSql(getText(app, "eyeColor"));
            String hairColor = escapeSql(getText(app, "hairColor"));

            Integer heightCm = parseMetric(app.get("height"), "cm");
            Integer weightKg = parseMetric(app.get("weight"), "kg");

            writer.printf(
                    "INSERT INTO superhero_appearance (superhero_id, gender, race, height_cm, weight_kg, eye_color, hair_color) VALUES (%d, %s, %s, %s, %s, %s, %s)%s;%n",
                    id, quoteOrNull(gender), quoteOrNull(race),
                    heightCm != null ? heightCm : "NULL",
                    weightKg != null ? weightKg : "NULL",
                    quoteOrNull(eyeColor), quoteOrNull(hairColor), onConflictId);
        }

        // Biography
        if (bio != null) {
            String fullName = escapeSql(getText(bio, "fullName"));
            String placeOfBirth = escapeSql(getText(bio, "placeOfBirth"));
            String firstAppearance = escapeSql(getText(bio, "firstAppearance"));

            // Aliases as JSON array
            String aliases = "[]";
            if (bio.has("aliases") && bio.get("aliases").isArray()) {
                try {
                    String json = new ObjectMapper().writeValueAsString(bio.get("aliases"));
                    aliases = escapeSql(json);
                } catch (Exception e) {
                    // ignore
                }
            }

            writer.printf(
                    "INSERT INTO superhero_biography (superhero_id, full_name, aliases, place_of_birth, first_appearance) VALUES (%d, %s, '%s', %s, %s)%s;%n",
                    id, quoteOrNull(fullName), aliases, quoteOrNull(placeOfBirth), quoteOrNull(firstAppearance),
                    onConflictId);
        }

        // Images
        JsonNode imgs = hero.get("images");
        if (imgs != null) {
            String xs = escapeSql(getText(imgs, "xs"));
            String sm = escapeSql(getText(imgs, "sm"));
            String md = escapeSql(getText(imgs, "md"));
            String lg = escapeSql(getText(imgs, "lg"));

            writer.printf(
                    "INSERT INTO superhero_images (superhero_id, xs_url, sm_url, md_url, lg_url) VALUES (%d, %s, %s, %s, %s)%s;%n",
                    id, quoteOrNull(xs), quoteOrNull(sm), quoteOrNull(md), quoteOrNull(lg), onConflictId);
        }
    }

    private static String getText(JsonNode node, String field) {
        if (node == null || !node.has(field) || node.get(field).isNull())
            return null;
        String text = node.get(field).asText();
        if ("-".equals(text) || "null".equalsIgnoreCase(text))
            return null;
        return text;
    }

    private static int getInt(JsonNode node, String field) {
        if (node == null || !node.has(field))
            return 0;
        return node.get(field).asInt(0);
    }

    private static String escapeSql(String val) {
        if (val == null)
            return null;
        return val.replace("'", "''");
    }

    private static String quoteOrNull(String val) {
        if (val == null)
            return "NULL";
        return "'" + val + "'";
    }

    // Simplistic parser for ["6'8", "203 cm"] format
    private static Integer parseMetric(JsonNode arrayNode, String suffix) {
        if (arrayNode == null || !arrayNode.isArray())
            return null;
        for (JsonNode node : arrayNode) {
            String val = node.asText();
            if (val != null && val.endsWith(suffix)) {
                try {
                    String num = val.replace(suffix, "").trim().replace(",", "");
                    return Integer.parseInt(num);
                } catch (NumberFormatException e) {
                    return null;
                }
            }
        }
        return null;
    }
}
